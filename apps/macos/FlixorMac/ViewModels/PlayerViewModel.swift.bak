//
//  PlayerViewModel.swift
//  FlixorMac
//
//  Video player view model with AVPlayer integration
//

import Foundation
import AVKit
import SwiftUI
import Combine

@MainActor
class PlayerViewModel: ObservableObject {
    // MARK: - Published Properties

    @Published var isPlaying = false
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isLoading = true
    @Published var error: String?
    @Published var volume: Float = 1.0
    @Published var isMuted = false
    @Published var isFullScreen = false

    // Stream info
    @Published var streamURL: URL?
    @Published var availableQualities: [String] = []
    @Published var selectedQuality: String = "Original"

    // Playback metadata
    let item: MediaItem
    private(set) var player: AVPlayer?
    private var timeObserver: Any?
    private var cancellables = Set<AnyCancellable>()
    private let api = APIClient.shared

    // Progress tracking
    private var progressTimer: Timer?
    private var lastReportedProgress: TimeInterval = 0

    init(item: MediaItem) {
        self.item = item
        setupPlayer()
    }

    deinit {
        // Cleanup synchronously in deinit
        if let observer = timeObserver {
            player?.removeTimeObserver(observer)
            timeObserver = nil
        }
        progressTimer?.invalidate()
        progressTimer = nil
        player?.pause()
        player = nil
        cancellables.removeAll()
        print("üßπ [Player] Cleaned up")
    }

    // MARK: - Player Setup

    private func setupPlayer() {
        Task {
            await loadStreamURL()
        }
    }

    private func loadStreamURL() async {
        isLoading = true
        error = nil

        do {
            // Extract ratingKey from item.id
            let ratingKey = item.id.replacingOccurrences(of: "plex:", with: "")

            guard !ratingKey.isEmpty else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid item ID: \(item.id)"])
            }

            print("üì∫ [Player] Fetching stream URL for ratingKey: \(ratingKey)")
            print("üì∫ [Player] Item title: \(item.title)")

            // Get Plex server connection details (like mobile app)
            let servers = try await api.getPlexServers()
            guard let activeServer = servers.first(where: { $0.isActive == true }) else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "No active Plex server configured"])
            }

            print("üì∫ [Player] Using server: \(activeServer.name)")

            let connectionsResponse = try await api.getPlexConnections(serverId: activeServer.id)
            let connections = connectionsResponse.connections

            // Prefer local connection, fall back to first available
            guard let selectedConnection = connections.first(where: { $0.local == true }) ?? connections.first else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "No Plex server connection available"])
            }

            let baseUrl = selectedConnection.uri.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            print("üì∫ [Player] Server URL: \(baseUrl)")

            // Get Plex access token
            let authServers = try await api.getPlexAuthServers()
            guard let serverWithToken = authServers.first(where: {
                $0.clientIdentifier == activeServer.id ||
                $0.clientIdentifier == activeServer.machineIdentifier
            }), let token = serverWithToken.token as String? else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Could not get Plex access token"])
            }

            print("üì∫ [Player] Got access token")

            // Use backend streaming endpoint (it handles HLS properly)
            print("üì∫ [Player] Requesting stream URL from backend")

            struct StreamResponse: Codable {
                let url: String
            }

            let response: StreamResponse = try await api.get(
                "/api/plex/stream/\(ratingKey)",
                queryItems: [URLQueryItem(name: "protocol", value: "hls")]
            )

            print("üì∫ [Player] Received stream URL: \(response.url)")

            guard let url = URL(string: response.url) else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid stream URL"])
            }

            self.streamURL = url
            print("‚úÖ [Player] Stream URL ready: \(url.absoluteString)")

            // Initialize AVPlayer
            let playerItem = AVPlayerItem(url: url)

            // Add error observer
            playerItem.publisher(for: \.error)
                .sink { [weak self] error in
                    if let error = error {
                        print("‚ùå [Player] AVPlayerItem error: \(error.localizedDescription)")
                        Task { @MainActor [weak self] in
                            self?.error = "Playback error: \(error.localizedDescription)"
                            self?.isLoading = false
                        }
                    }
                }
                .store(in: &cancellables)

            self.player = AVPlayer(playerItem: playerItem)

            // Setup observers
            setupTimeObserver()
            setupPlayerObservers(playerItem: playerItem)

            // Auto-play
            self.player?.play()
            self.isPlaying = true
            self.isLoading = false

            // Start progress tracking
            startProgressTracking()

        } catch {
            print("‚ùå [Player] Failed to load stream: \(error)")
            self.error = "Failed to load video stream: \(error.localizedDescription)"
            self.isLoading = false
        }
    }

    // REMOVE ALL THE CODE BELOW - using backend endpoint instead
    /*
            // First, fetch metadata to get media parts
            let metadataUrl = "\(baseUrl)/library/metadata/\(ratingKey)?X-Plex-Token=\(token)"
            guard let metadataURL = URL(string: metadataUrl) else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid metadata URL"])
            }

            print("üì∫ [Player] Fetching media metadata")
            let (metadataData, _) = try await URLSession.shared.data(from: metadataURL)

            // Parse XML to get media part key
            // For now, we'll use a simple string search to get the part key
            guard let metadataXML = String(data: metadataData, encoding: .utf8) else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to parse metadata"])
            }

            // Extract part key from XML - look specifically for Part element's key attribute
            var partKey: String?
            // Look for <Part ... key="/library/parts/..." />
            if let partMatch = metadataXML.range(of: "<Part[^>]+key=\"([^\"]+)\"", options: .regularExpression) {
                let matchString = String(metadataXML[partMatch])
                if let keyStart = matchString.range(of: "key=\"")?.upperBound,
                   let keyEnd = matchString[keyStart...].range(of: "\"")?.lowerBound {
                    partKey = String(matchString[keyStart..<keyEnd])
                }
            }

            print("üì∫ [Player] Part key: \(partKey ?? "none")")

            // Check if file extension is natively supported by AVPlayer
            let fileExtension = (partKey?.lowercased() ?? "").split(separator: ".").last.map(String.init) ?? ""
            let nativelySupported = ["mp4", "m4v", "mov", "m4a", "mp3"].contains(fileExtension)

            if let partKey = partKey, nativelySupported {
                print("üì∫ [Player] Using direct play (native format: \(fileExtension))")
                let directUrl = "\(baseUrl)\(partKey)?X-Plex-Token=\(token)"
                guard let directURL = URL(string: directUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid direct stream URL"])
                }

                self.streamURL = directURL
                print("‚úÖ [Player] Direct play URL: \(directUrl)")
            } else if let partKey = partKey {
                // File needs conversion - use Plex's HLS transcode
                print("üì∫ [Player] Using HLS transcode (format: \(fileExtension))")

                let sessionId = UUID().uuidString

                // Start the transcode session first (match mobile app exactly)
                let startParams: [URLQueryItem] = [
                    URLQueryItem(name: "hasMDE", value: "1"),
                    URLQueryItem(name: "path", value: "/library/metadata/\(ratingKey)"),
                    URLQueryItem(name: "mediaIndex", value: "0"),
                    URLQueryItem(name: "partIndex", value: "0"),
                    URLQueryItem(name: "protocol", value: "hls"),
                    URLQueryItem(name: "fastSeek", value: "1"),
                    URLQueryItem(name: "directPlay", value: "0"),
                    URLQueryItem(name: "directStream", value: "0"),
                    URLQueryItem(name: "directStreamAudio", value: "0"),
                    URLQueryItem(name: "subtitleSize", value: "100"),
                    URLQueryItem(name: "audioBoost", value: "100"),
                    URLQueryItem(name: "location", value: "lan"),
                    URLQueryItem(name: "addDebugOverlay", value: "0"),
                    URLQueryItem(name: "autoAdjustQuality", value: "0"),
                    URLQueryItem(name: "mediaBufferSize", value: "102400"),
                    URLQueryItem(name: "session", value: sessionId),
                    URLQueryItem(name: "videoQuality", value: "100"),
                    URLQueryItem(name: "videoResolution", value: "1920x1080"),
                    URLQueryItem(name: "maxVideoBitrate", value: "20000"),
                    URLQueryItem(name: "copyts", value: "1"),
                    URLQueryItem(name: "X-Plex-Platform", value: "macOS"),
                    URLQueryItem(name: "X-Plex-Client-Identifier", value: sessionId),
                    URLQueryItem(name: "X-Plex-Product", value: "Flixor Mac"),
                    URLQueryItem(name: "X-Plex-Device", value: "Mac"),
                    URLQueryItem(name: "X-Plex-Token", value: token)
                ]

                var components = URLComponents()
                components.queryItems = startParams
                guard let queryString = components.query else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to build stream params"])
                }

                // Start the session
                let startUrl = "\(baseUrl)/video/:/transcode/universal/start.m3u8?\(queryString)"
                guard let startURL = URL(string: startUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid start URL"])
                }

                print("üì∫ [Player] Starting HLS session")
                let (_, startResponse) = try await URLSession.shared.data(from: startURL)
                if let httpResponse = startResponse as? HTTPURLResponse {
                    print("üì∫ [Player] Start response: \(httpResponse.statusCode)")
                }

                // Wait briefly for session to initialize
                try? await Task.sleep(nanoseconds: 500_000_000)

                // Now use the session URL
                let streamUrl = "\(baseUrl)/video/:/transcode/universal/session/\(sessionId)/base/index.m3u8?X-Plex-Token=\(token)"
                guard let streamURL = URL(string: streamUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid stream URL"])
                }

                self.streamURL = streamURL
                print("‚úÖ [Player] HLS session URL: \(streamUrl)")

                // Initialize AVPlayer
                let playerItem = AVPlayerItem(url: streamURL)

                // Add error observer before creating player
                playerItem.publisher(for: \.error)
                    .sink { [weak self] error in
                        if let error = error {
                            print("‚ùå [Player] AVPlayerItem error: \(error.localizedDescription)")
                            Task { @MainActor [weak self] in
                                self?.error = "Playback error: \(error.localizedDescription)"
                                self?.isLoading = false
                            }
                        }
                    }
                    .store(in: &cancellables)

                self.player = AVPlayer(playerItem: playerItem)

                // Setup observers
                setupTimeObserver()
                setupPlayerObservers(playerItem: playerItem)

                // Auto-play
                self.player?.play()
                self.isPlaying = true
                self.isLoading = false

                // Start progress tracking
                startProgressTracking()

                return // Exit early with direct stream
            }

            // Fallback: Generate session ID and request streaming decision
            let sessionId = UUID().uuidString

            // Request streaming decision from Plex (like mobile app)
            let decisionUrl = "\(baseUrl)/video/:/transcode/universal/decision"
            let decisionParams: [URLQueryItem] = [
                URLQueryItem(name: "X-Plex-Token", value: token),
                URLQueryItem(name: "path", value: "/library/metadata/\(ratingKey)"),
                URLQueryItem(name: "mediaIndex", value: "0"),
                URLQueryItem(name: "partIndex", value: "0"),
                URLQueryItem(name: "protocol", value: "hls"),
                URLQueryItem(name: "directPlay", value: "1"),
                URLQueryItem(name: "directStream", value: "1"),
                URLQueryItem(name: "subtitleSize", value: "100"),
                URLQueryItem(name: "audioBoost", value: "100"),
                URLQueryItem(name: "location", value: "lan"),
                URLQueryItem(name: "session", value: sessionId),
                URLQueryItem(name: "X-Plex-Product", value: "Flixor Mac"),
                URLQueryItem(name: "X-Plex-Version", value: "1.0.0"),
                URLQueryItem(name: "X-Plex-Client-Identifier", value: sessionId),
                URLQueryItem(name: "X-Plex-Platform", value: "macOS"),
                URLQueryItem(name: "X-Plex-Device", value: "Mac"),
                URLQueryItem(name: "X-Plex-Device-Name", value: "Mac")
            ]

            var decisionComponents = URLComponents()
            decisionComponents.queryItems = decisionParams
            guard let decisionQueryString = decisionComponents.query,
                  let fullDecisionUrl = URL(string: "\(decisionUrl)?\(decisionQueryString)") else {
                throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to build decision URL"])
            }

            print("üì∫ [Player] Decision URL: \(fullDecisionUrl.absoluteString.prefix(200))...")

            print("üì∫ [Player] Requesting streaming decision from Plex")

            // Make decision request
            let (decisionData, decisionResponse) = try await URLSession.shared.data(from: fullDecisionUrl)
            if let httpResponse = decisionResponse as? HTTPURLResponse {
                print("üì∫ [Player] Decision response: \(httpResponse.statusCode)")
            }
            let decisionText = String(data: decisionData, encoding: .utf8) ?? ""
            print("üì∫ [Player] Decision XML (first 500 chars): \(decisionText.prefix(500))")

            // Check if direct play is supported
            let canDirectPlay = decisionText.contains("directPlayDecisionCode=\"1000\"")

            // Also check for direct stream
            let canDirectStream = decisionText.contains("directStreamDecisionCode=\"1000\"")

            print("üì∫ [Player] Decision - Direct Play: \(canDirectPlay), Direct Stream: \(canDirectStream)")

            let url: URL
            if (canDirectPlay || canDirectStream), let partKey = partKey {
                print("üì∫ [Player] Using direct play/stream")
                // Direct play/stream - use media part URL directly (like mobile app)
                let directUrl = "\(baseUrl)\(partKey)?X-Plex-Token=\(token)"
                guard let directURL = URL(string: directUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid direct play URL"])
                }
                url = directURL
                print("üì∫ [Player] Direct URL: \(directUrl)")
            } else {
                print("üì∫ [Player] Using transcode")
                // Transcode - start session and get HLS URL (match mobile app params)
                let transcodeParams: [URLQueryItem] = [
                    URLQueryItem(name: "hasMDE", value: "1"),
                    URLQueryItem(name: "path", value: "/library/metadata/\(ratingKey)"),
                    URLQueryItem(name: "mediaIndex", value: "0"),
                    URLQueryItem(name: "partIndex", value: "0"),
                    URLQueryItem(name: "protocol", value: "hls"),
                    URLQueryItem(name: "fastSeek", value: "1"),
                    URLQueryItem(name: "directPlay", value: "0"),
                    URLQueryItem(name: "directStream", value: "0"),
                    URLQueryItem(name: "directStreamAudio", value: "0"),
                    URLQueryItem(name: "subtitleSize", value: "100"),
                    URLQueryItem(name: "audioBoost", value: "100"),
                    URLQueryItem(name: "location", value: "lan"),
                    URLQueryItem(name: "addDebugOverlay", value: "0"),
                    URLQueryItem(name: "autoAdjustQuality", value: "0"),
                    URLQueryItem(name: "mediaBufferSize", value: "102400"),
                    URLQueryItem(name: "session", value: sessionId),
                    URLQueryItem(name: "videoQuality", value: "100"),
                    URLQueryItem(name: "videoResolution", value: "1920x1080"),
                    URLQueryItem(name: "maxVideoBitrate", value: "20000"),
                    URLQueryItem(name: "copyts", value: "1"),
                    URLQueryItem(name: "X-Plex-Platform", value: "macOS"),
                    URLQueryItem(name: "X-Plex-Client-Identifier", value: sessionId),
                    URLQueryItem(name: "X-Plex-Product", value: "Flixor Mac"),
                    URLQueryItem(name: "X-Plex-Device", value: "Mac"),
                    URLQueryItem(name: "X-Plex-Token", value: token)
                ]

                // Build query string from parameters
                var components = URLComponents()
                components.queryItems = transcodeParams
                guard let transcodeParamsString = components.query else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to build transcode params"])
                }

                // Start transcode session
                let startUrl = "\(baseUrl)/video/:/transcode/universal/start.m3u8?\(transcodeParamsString)"
                guard let startURL = URL(string: startUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid start URL"])
                }
                print("üì∫ [Player] Starting transcode session")
                let (startData, startResponse) = try await URLSession.shared.data(from: startURL)
                if let httpResponse = startResponse as? HTTPURLResponse {
                    print("üì∫ [Player] Transcode start response: \(httpResponse.statusCode)")
                    if httpResponse.statusCode != 200 {
                        let errorText = String(data: startData, encoding: .utf8) ?? "unknown error"
                        print("‚ùå [Player] Transcode start failed: \(errorText)")
                    }
                }

                // Wait a moment for session to initialize
                try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

                // Get HLS session URL
                let hlsUrl = "\(baseUrl)/video/:/transcode/universal/session/\(sessionId)/base/index.m3u8?X-Plex-Token=\(token)"
                print("üì∫ [Player] HLS session URL: \(hlsUrl)")
                guard let hlsURL = URL(string: hlsUrl) else {
                    throw NSError(domain: "PlayerError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid HLS URL"])
                }
                url = hlsURL
            }

            self.streamURL = url
            print("‚úÖ [Player] Stream URL: \(url.absoluteString)")

            // Initialize AVPlayer
            let playerItem = AVPlayerItem(url: url)

            // Add error observer before creating player
            playerItem.publisher(for: \.error)
                .sink { [weak self] error in
                    if let error = error {
                        print("‚ùå [Player] AVPlayerItem error: \(error.localizedDescription)")
                        Task { @MainActor [weak self] in
                            self?.error = "Playback error: \(error.localizedDescription)"
                            self?.isLoading = false
                        }
                    }
                }
                .store(in: &cancellables)

            self.player = AVPlayer(playerItem: playerItem)

            // Setup observers
            setupTimeObserver()
            setupPlayerObservers(playerItem: playerItem)

            // Auto-play
            self.player?.play()
            self.isPlaying = true
            self.isLoading = false

            // Start progress tracking
            startProgressTracking()

        } catch {
            print("‚ùå [Player] Failed to load stream: \(error)")
            self.error = "Failed to load video stream: \(error.localizedDescription)"
            self.isLoading = false
        }
    }

    // MARK: - Player Observers

    private func setupTimeObserver() {
        guard let player = player else { return }

        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = player.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            Task { @MainActor [weak self] in
                guard let self = self else { return }
                self.currentTime = time.seconds

                // Update duration if available
                if let duration = player.currentItem?.duration.seconds, !duration.isNaN {
                    self.duration = duration
                }
            }
        }
    }

    private func setupPlayerObservers(playerItem: AVPlayerItem) {
        // Observe status
        playerItem.publisher(for: \.status)
            .sink { [weak self] status in
                Task { @MainActor [weak self] in
                    guard let self = self else { return }
                    switch status {
                    case .readyToPlay:
                        print("‚úÖ [Player] Ready to play")
                        self.isLoading = false
                    case .failed:
                        print("‚ùå [Player] Failed: \(playerItem.error?.localizedDescription ?? "Unknown error")")
                        self.error = playerItem.error?.localizedDescription ?? "Playback failed"
                        self.isLoading = false
                    case .unknown:
                        print("‚è≥ [Player] Status unknown")
                    @unknown default:
                        break
                    }
                }
            }
            .store(in: &cancellables)

        // Observe playback end
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: playerItem)
            .sink { [weak self] _ in
                Task { @MainActor [weak self] in
                    guard let self = self else { return }
                    print("‚úÖ [Player] Playback finished")
                    self.handlePlaybackEnd()
                }
            }
            .store(in: &cancellables)

        // Observe stalls
        NotificationCenter.default.publisher(for: .AVPlayerItemPlaybackStalled, object: playerItem)
            .sink { [weak self] _ in
                Task { @MainActor [weak self] in
                    guard let self = self else { return }
                    print("‚ö†Ô∏è [Player] Playback stalled")
                    self.isLoading = true
                }
            }
            .store(in: &cancellables)
    }

    // MARK: - Playback Controls

    func togglePlayPause() {
        guard let player = player else { return }

        if isPlaying {
            player.pause()
            isPlaying = false
            stopProgressTracking()
        } else {
            player.play()
            isPlaying = true
            startProgressTracking()
        }
    }

    func seek(to time: TimeInterval) {
        guard let player = player else { return }
        let cmTime = CMTime(seconds: time, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        player.seek(to: cmTime) { [weak self] finished in
            if finished {
                print("‚úÖ [Player] Seeked to \(time)s")
                Task { @MainActor [weak self] in
                    await self?.reportProgress()
                }
            }
        }
    }

    func skip(seconds: TimeInterval) {
        let newTime = max(0, min(duration, currentTime + seconds))
        seek(to: newTime)
    }

    func setVolume(_ volume: Float) {
        self.volume = volume
        player?.volume = isMuted ? 0 : volume
    }

    func toggleMute() {
        isMuted.toggle()
        player?.volume = isMuted ? 0 : volume
    }

    func changeQuality(_ quality: String) {
        selectedQuality = quality
        let savedTime = currentTime

        Task {
            await loadStreamURL()
            // Restore playback position
            if savedTime > 0 {
                seek(to: savedTime)
            }
        }
    }

    // MARK: - Progress Tracking

    private func startProgressTracking() {
        progressTimer?.invalidate()
        progressTimer = Timer.scheduledTimer(withTimeInterval: 10.0, repeats: true) { [weak self] _ in
            Task { @MainActor [weak self] in
                await self?.reportProgress()
            }
        }
    }

    private func stopProgressTracking() {
        progressTimer?.invalidate()
        progressTimer = nil
    }

    private func reportProgress() async {
        guard currentTime > 0, duration > 0 else { return }

        // Only report if progress changed significantly (more than 5 seconds)
        guard abs(currentTime - lastReportedProgress) > 5 else { return }

        lastReportedProgress = currentTime

        let progressPercent = Int((currentTime / duration) * 100)
        print("üìä [Player] Progress: \(Int(currentTime))s / \(Int(duration))s (\(progressPercent)%)")

        do {
            let ratingKey = item.id.replacingOccurrences(of: "plex:", with: "")
            struct ProgressRequest: Encodable {
                let ratingKey: String
                let time: Int
                let duration: Int
                let state: String
            }
            let request = ProgressRequest(
                ratingKey: ratingKey,
                time: Int(currentTime * 1000),
                duration: Int(duration * 1000),
                state: isPlaying ? "playing" : "paused"
            )
            let _: EmptyResponse = try await api.post("/api/plex/progress", body: request)
        } catch {
            print("‚ö†Ô∏è [Player] Failed to report progress: \(error)")
        }
    }

    private func handlePlaybackEnd() {
        isPlaying = false
        stopProgressTracking()

        // Mark as watched
        Task {
            do {
                let ratingKey = item.id.replacingOccurrences(of: "plex:", with: "")
                struct ScrobbleRequest: Encodable {
                    let ratingKey: String
                }
                let _: EmptyResponse = try await api.post("/api/plex/scrobble", body: ScrobbleRequest(ratingKey: ratingKey))
                print("‚úÖ [Player] Marked as watched")
            } catch {
                print("‚ö†Ô∏è [Player] Failed to mark as watched: \(error)")
            }
        }
    }

    // MARK: - Cleanup

    func onDisappear() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            await self.reportProgress() // Final progress report

            if let observer = self.timeObserver {
                self.player?.removeTimeObserver(observer)
                self.timeObserver = nil
            }
            self.stopProgressTracking()
            self.player?.pause()
            self.player = nil
            self.cancellables.removeAll()
        }
    }
}

// MARK: - Helper Response Types

struct EmptyResponse: Codable {}
